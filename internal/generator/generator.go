// Package generator - provides functions to generate TypeScript bindings from Go code.
package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/limbicnode/go2ts/internal/parser"
)

const (
	structEstimatedSize = 200
	aliasEstimatedSize  = 50
	baseEstimatedSize   = 300
)

func buildAliasMap(aliases []parser.TypeAlias) map[string]string {
	m := map[string]string{}
	for _, alias := range aliases {
		m[alias.Name] = alias.Underlying
	}
	return m
}

func buildStructMap(structs []parser.GoStruct) map[string]parser.StructInfo {
	m := map[string]parser.StructInfo{}
	for _, s := range structs {
		fields := make([]parser.FieldInfo, len(s.Fields))
		for i, f := range s.Fields {
			fields[i] = parser.FieldInfo(f)
		}
		m[s.Name] = parser.StructInfo{
			Name:       s.Name,
			TypeParams: s.TypeParams,
			Fields:     fields,
		}
	}
	return m
}

func fieldToTS(f parser.StructField,
	aliasMap map[string]string,
	typeParams []string,
	structMap map[string]parser.StructInfo,
	typeParamMapping map[string]string) string {
	fieldName := ExtractJSONTag(f.Tags)
	if fieldName == "" {
		fieldName = f.Name
	}

	emptyGenericMap := map[string]bool{}
	tsType := parser.GoTypeToTSType(f.Type,
		aliasMap,
		typeParams,
		structMap,
		typeParamMapping,
		emptyGenericMap)
	if tsType == "" {
		tsType = "any"
	}

	return fmt.Sprintf("  %s: %s;\n", fieldName, tsType)
}

func generateStructTS(s parser.GoStruct,
	aliasMap map[string]string,
	structMap map[string]parser.StructInfo) string {
	typeParams := s.TypeParams
	typeParamMapping := map[string]string{}
	for _, param := range typeParams {
		typeParamMapping[param] = param
	}

	typeParamsStr := ""
	if len(typeParams) > 0 {
		typeParamsStr = "<" + strings.Join(typeParams, ", ") + ">"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("export interface %s%s {\n", s.Name, typeParamsStr))

	for _, f := range s.Fields {
		sb.WriteString(fieldToTS(f, aliasMap, typeParams, structMap, typeParamMapping))
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

func generateAliasTS(alias parser.TypeAlias,
	aliasMap map[string]string,
	structMap map[string]parser.StructInfo) string {
	typeParams := alias.TypeParams
	typeParamMapping := map[string]string{}
	for _, param := range typeParams {
		typeParamMapping[param] = param
	}

	tsType := alias.Underlying
	if tsType == "interface{}" {
		tsType = "any"
	} else {
		tsType = parser.GoTypeToTSType(tsType, aliasMap, typeParams, structMap, typeParamMapping, map[string]bool{})
		if tsType == "" {
			tsType = "any"
		}
	}

	typeParamsStr := ""
	if len(typeParams) > 0 {
		typeParamsStr = "<" + strings.Join(typeParams, ", ") + ">"
	}

	return fmt.Sprintf("export type %s%s = %s;\n\n", alias.Name, typeParamsStr, tsType)
}

// GenerateTypeScript - generates TypeScript type definitions from Go struct data.
func GenerateTypeScript(data parser.GoFileData, outPath string) error {
	aliasMap := buildAliasMap(data.Aliases)
	structMap := buildStructMap(data.Structs)

	var sb strings.Builder
	estimatedSize := len(data.Structs)*structEstimatedSize + len(data.Aliases)*aliasEstimatedSize + baseEstimatedSize
	sb.Grow(estimatedSize)

	now := time.Now().Format("2006-01-02 15:04:05")
	sb.WriteString(fmt.Sprintf("// Generated by go2ts â€” %s\n\n", now))

	seenAliases := map[string]bool{}

	for _, alias := range data.Aliases {
		if seenAliases[alias.Name] {
			continue
		}
		seenAliases[alias.Name] = true
		sb.WriteString(generateAliasTS(alias, aliasMap, structMap))
	}

	for _, s := range data.Structs {
		sb.WriteString(generateStructTS(s, aliasMap, structMap))
	}

	outPath = filepath.Clean(outPath)
	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := f.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()
	_, err = f.WriteString(sb.String())
	return err
}

// ExtractJSONTag - extracts the JSON tag name from a struct field tag.
func ExtractJSONTag(tag string) string {
	if tag == "" {
		return ""
	}
	name := reflect.StructTag(tag).Get("json")
	if name == "" || name == "-" {
		return ""
	}
	if comma := strings.IndexByte(name, ','); comma != -1 {
		name = name[:comma]
	}
	return name
}
